# import requests
# from selenium import webdriver
# from selenium.webdriver.common.by import By
# from selenium.webdriver.support.ui import WebDriverWait
# from selenium.webdriver.support import expected_conditions as EC
# from tkinter import messagebox
# import threading    
# import tkinter as tk
# from tkinter import messagebox, scrolledtext
# import logging
# import sqlite3

# # Configure logging
# logging.basicConfig(filename='Vulnerability_scanner.log', level=logging.INFO,
#                     format='%(asctime)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

# class VulnerabilityScannerApp(tk.Tk):
#     def __init__(self):
#         super().__init__()
#         self.title("Vulnerability Scanner")
#         self.geometry("600x400")

#         # Create a scrolled text widget for log messages
#         self.log_widget = scrolledtext.ScrolledText(self, state='disabled', height=15)
#         self.log_widget.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

#         self.display_banner()
#         self.initialize_database()


#     def log_message(self, message, level='info'):
#         """
#         Log a message to the log widget and to the file.

#         Args:
#             message (str): The message to log.
#             level (str): The logging level ('info', 'warning', 'error').
#         """
#         self.log_widget.config(state='normal')
#         self.log_widget.insert(tk.END, message + '\n')
#         self.log_widget.config(state='disabled')
#         self.log_widget.yview(tk.END)

#         if level == 'info':
#             logging.info(message)
#         elif level == 'warning':
#             logging.warning(message)
#         elif level == 'error':
#             logging.error(message)

#     def display_banner(self):
#         """Display the application banner."""
#         try:
#             with open('Config/Banner.txt', 'r', encoding='utf-8') as file:
#                 banner = file.read()
#                 self.log_message(banner, 'info')
#         except FileNotFoundError:
#             self.log_message("Banner file (Config/Banner.txt) not found.", 'error')

#     # Adapt other methods (e.g., read_payloads_from_file) to work with the GUI as needed

# if __name__ == "__main__":
#     app = VulnerabilityScannerApp()

# # Utility function to append messages to the GUI output widget
# def append_output(widget, message):
#     widget.insert('end', message + "\n")
#     widget.see('end')  # Auto-scroll
#     def initialize_database(self):
#         self.conn = sqlite3.connect('vulnerability_scanner.db')
#         c = self.conn.cursor()
#         # Create tables for different scans
#         c.execute('''CREATE TABLE IF NOT EXISTS xss_scans
#                      (id INTEGER PRIMARY KEY, url TEXT, payload TEXT, result TEXT)''')
#         c.execute('''CREATE TABLE IF NOT EXISTS sql_injection_scans
#                      (id INTEGER PRIMARY KEY, url TEXT, payload TEXT, result TEXT)''')
#         c.execute('''CREATE TABLE IF NOT EXISTS server_side_scans
#                      (id INTEGER PRIMARY KEY, url TEXT, payload TEXT, result TEXT)''')
#         c.execute('''CREATE TABLE IF NOT EXISTS open_redirection_scans
#                      (id INTEGER PRIMARY KEY, url TEXT, payload TEXT, result TEXT)''')
#         c.execute('''CREATE TABLE IF NOT EXISTS clickjacking_scans
#                      (id INTEGER PRIMARY KEY, url TEXT, payload TEXT, result TEXT)''')
#         c.execute('''CREATE TABLE IF NOT EXISTS subdomain_scans
#                      (id INTEGER PRIMARY KEY, domain TEXT, subdomain TEXT, ip_address TEXT)''')
#         self.conn.commit()
# def log_xss_scan(url, payload, result):
#     conn = sqlite3.connect('vulnerability_scanner.db')
#     c = conn.cursor()
#     c.execute('INSERT INTO xss_scans (url, payload, result) VALUES (?, ?, ?)', (url, payload, result))
#     conn.commit()
#     conn.close()

# def log_sql_injection_scan(url, payload, result):
#     conn = sqlite3.connect('vulnerability_scanner.db')
#     c = conn.cursor()
#     c.execute('INSERT INTO sql_injection_scans (url, payload, result) VALUES (?, ?, ?)', (url, payload, result))
#     conn.commit()
#     conn.close()

# def log_server_side_scan(url, payload, result):
#     conn = sqlite3.connect('vulnerability_scanner.db')
#     c = conn.cursor()
#     c.execute('INSERT INTO server_side_scans (url, payload, result) VALUES (?, ?, ?)', (url, payload, result))
#     conn.commit()
#     conn.close()

# def log_open_redirection_scan(url, payload, result):
#     conn = sqlite3.connect('vulnerability_scanner.db')
#     c = conn.cursor()
#     c.execute('INSERT INTO open_redirection_scans (url, payload, result) VALUES (?, ?, ?)', (url, payload, result))
#     conn.commit()
#     conn.close()

# def log_clickjacking_scan(url, result):
#     conn = sqlite3.connect('vulnerability_scanner.db')
#     c = conn.cursor()
#     c.execute('INSERT INTO clickjacking_scans (url, result) VALUES (?, ?)', (url, result))
#     conn.commit()
#     conn.close()

# def log_subdomain_scan(domain, subdomain, ip_address):
#     conn = sqlite3.connect('vulnerability_scanner.db')
#     c = conn.cursor()
#     c.execute('INSERT INTO subdomain_scans (domain, subdomain, ip_address) VALUES (?, ?, ?)', (domain, subdomain, ip_address))
#     conn.commit()
#     conn.close()

# def test_reflected_xss(url, payloads, output_widget):
#     """
#     Test for reflected XSS vulnerability and log results to database.
#     """
#     append_output(output_widget, "Starting Reflected XSS test...")
#     for payload in payloads:
#         try:
#             response = requests.post(url, data={'message': payload})
#             if payload in response.text:
#                 result = "Vulnerable"
#                 log_xss_scan(url, payload, result)
#                 append_output(output_widget, f"Possible Reflected XSS found with payload: {payload}")
#             else:
#                 result = "Not Vulnerable"
#                 log_xss_scan(url, payload, result)
#                 # append_output(output_widget, f"No XSS detected with payload: {payload}")
#         except requests.exceptions.RequestException as e:
#             # append_output(output_widget, f"Error testing payload {payload}: {str(e)}")
#             pass
#     append_output(output_widget, "Reflected XSS test completed.")


# def append_output(widget, message):
#     """
#     Append a message to the output widget in the GUI.

#     Args:
#         widget: The Tkinter Text or ScrolledText widget where output should be displayed.
#         message (str): The message to append to the widget.
#     """
#     widget.insert('end', message + "\n")
#     widget.see('end')  # Auto-scroll to the bottom

# def test_sql_injection(url, payloads, output_widget, method):
#     """
#     Test for SQL Injection vulnerability, adapted for GUI.

#     Args:
#         url (str): The target URL to test.
#         payloads (list): A list of payloads for testing SQL Injection.
#         output_widget: The Tkinter Text or ScrolledText widget to display output.
#         method (str): The method of injection ('1', '2', or '3').
#     """
#     append_output(output_widget, "Starting SQL Injection test...")

#     if method == '1':
#         # Method 1: Injecting into URL parameters
#         for payload in payloads:
#             try:
#                 response = requests.get(f"{url}?username={payload}&password=dummy")
#                 if response.status_code == 200 and 'Welcome' in response.text:
#                     append_output(output_widget, f"URL: {url} - Payload: {payload} - SQL Injection (Method 1) - Vulnerable")
#                 else:
#                     append_output(output_widget, f"URL: {url} - Payload: {payload} - Not Vulnerable (Method 1)")
#             except requests.exceptions.RequestException as e:
#                 append_output(output_widget, f"Error (requests): {e}")

#     elif method == '2':
#         # Method 2: Injecting into POST form data
#         for payload in payloads:
#             try:
#                 data = {'username': payload, 'password': 'dummy'}
#                 response = requests.post(url, data=data)
#                 if response.status_code == 200 and 'Welcome' in response.text:
#                     append_output(output_widget, f"URL: {url} - Payload: {payload} - SQL Injection (Method 2) - Vulnerable")
#                 else:
#                     append_output(output_widget, f"URL: {url} - Payload: {payload} - Not Vulnerable (Method 2)")
#             except requests.exceptions.RequestException as e:
#                 append_output(output_widget, f"Error (requests): {e}")

#     elif method == '3':
#         # Method 3: Injecting into cookies
#         for payload in payloads:
#             try:
#                 cookies = {'username': payload, 'password': 'dummy'}
#                 response = requests.get(url, cookies=cookies)
#                 if response.status_code == 200 and 'Welcome' in response.text:
#                     append_output(output_widget, f"URL: {url} - Payload: {payload} - SQL Injection (Method 3) - Vulnerable")
#                 else:
#                     append_output(output_widget, f"URL: {url} - Payload: {payload} - Not Vulnerable (Method 3)")
#             except requests.exceptions.RequestException as e:
#                 append_output(output_widget, f"Error (requests): {e}")
#     else:
#         append_output(output_widget, "Invalid SQL injection method. Please enter either '1', '2', or '3'.")

#     append_output(output_widget, "SQL Injection test completed.")


# # Placeholder functions for other tests. Implement similar to the above examples.

# def test_server_side_template_injection(url, payloads, output_widget):
#     """
#     Test for Server-Side Template Injection vulnerability, adapted for GUI.

#     Args:
#         url (str): The target URL to test.
#         payloads (list): A list of payloads for testing SSTI.
#         output_widget: The Tkinter Text or ScrolledText widget to display output.
#     """
#     append_output(output_widget, "Starting SSTI test...")
#     for payload in payloads:
#         try:
#             data = {'template': payload}  # Adjust the data field name as per the target application
#             response = requests.post(url, data=data)
#             if 'SSTI_SUCCESS' in response.text:
#                 append_output(output_widget, f"Payload: {payload} - Server-Side Template Injection FOUND!")
#             else:
#                 append_output(output_widget, f"Payload: {payload} - Not Vulnerable")
#         except requests.exceptions.RequestException as e:
#             append_output(output_widget, f"Error (requests): {e}")
#     append_output(output_widget, "SSTI test completed.")
    

# def test_open_redirection(url, payloads, output_widget):
#     """
#     Test for Open Redirection vulnerability, adapted for GUI.

#     Args:
#         url (str): The target URL to test.
#         payloads (list): A list of payloads for testing Open Redirection.
#         output_widget: The Tkinter Text or ScrolledText widget to display output.
#     """
#     append_output(output_widget, "Starting Open Redirection test...")
#     for payload in payloads:
#         try:
#             response = requests.get(f"{url}?redirect={payload}", allow_redirects=False)
#             if response.status_code == 302 and 'Location' in response.headers:
#                 append_output(output_widget, f"Payload: {payload} - Open Redirection FOUND! Redirect URL: {response.headers['Location']}")
#             else:
#                 append_output(output_widget, f"Payload: {payload} - Not Vulnerable")
#         except requests.exceptions.RequestException as e:
#             append_output(output_widget, f"Error (requests): {e}")
#     append_output(output_widget, "Open Redirection test completed.") 

# def test_clickjacking(url, output_widget):
#     """
#     Test for Clickjacking vulnerability, adapted for GUI.

#     Args:
#         url (str): The target URL to test.
#         output_widget: The Tkinter Text or ScrolledText widget to display output.
#     """
#     append_output(output_widget, "Starting Clickjacking test...")
#     try:
#         headers = {
#             'Content-Security-Policy': "frame-ancestors 'none'",
#             'X-Frame-Options': 'deny',
#         }
#         response = requests.get(url, headers=headers)

#         if response.status_code == 200:
#             if 'X-Frame-Options' in response.headers and response.headers['X-Frame-Options'].lower() in ['deny', 'sameorigin']:
#                 append_output(output_widget, f"URL: {url} - X-Frame-Options is set to {response.headers['X-Frame-Options']}. Clickjacking may be mitigated.")
#             elif 'Content-Security-Policy' in response.headers and "frame-ancestors 'none'" in response.headers['Content-Security-Policy']:
#                 append_output(output_widget, f"URL: {url} - Content-Security-Policy is set. Clickjacking may be mitigated.")
#             else:
#                 append_output(output_widget, f"URL: {url} - Potential Clickjacking vulnerability detected. No protection headers found.")
#         else:
#             append_output(output_widget, f"URL: {url} - Unexpected response status code: {response.status_code}")
#     except requests.exceptions.RequestException as e:
#         append_output(output_widget, f"Error (requests): {e}")

#     append_output(output_widget, "Clickjacking test completed.")

# def test_reflected_xss_payloads(url, payloads, output_widget):
#     """
#     Test for reflected XSS vulnerability, adapted for GUI.

#     Args:
#         url (str): The target URL to test.
#         payloads (list): A list of payloads for testing Reflected XSS.
#         output_widget: The Tkinter Text or ScrolledText widget to display output.
#     """
#     def test_payloads_thread(payloads_subset):
    
#         """
#         Test a subset of payloads in a separate thread.

#         Args:
#             payloads_subset (list): A subset of payloads to test.
#         """
#         for payload in payloads_subset:
#             try:
#                 data = {'message': payload}
#                 response = requests.post(url, data=data)
#                 if 'XSS' in response.text:
#                     append_output(output_widget, f"URL: {url} - Payload: {payload} - XSS Found (via requests)")
#                 else:
#                     # append_output(output_widget, f"URL: {url} - Payload: {payload} - No XSS (via requests)")
#                     pass
#             except requests.exceptions.RequestException as e:
#                 append_output(output_widget, f"Error (requests): {e}")

#     append_output(output_widget, "Starting Reflected XSS test...")

#     num_threads = min(10, len(payloads))  # Use up to 10 threads, but not more than the number of payloads
#     payloads_per_thread = len(payloads) // num_threads
#     threads = []

#     for i in range(num_threads):
#         start_idx = i * payloads_per_thread
#         end_idx = start_idx + payloads_per_thread if i < num_threads - 1 else len(payloads)
#         thread = threading.Thread(target=test_payloads_thread, args=(payloads[start_idx:end_idx],))
#         threads.append(thread)
#         thread.start()

#     for thread in threads:
#         thread.join()

#     append_output(output_widget, "Reflected XSS test completed.")